// Code generated by mockery v2.49.0. DO NOT EDIT.

package mocks

import (
	bytes "github.com/berachain/beacon-kit/primitives/bytes"
	common "github.com/berachain/beacon-kit/primitives/common"

	consensus_typestypes "github.com/berachain/beacon-kit/consensus-types/types"

	math "github.com/berachain/beacon-kit/primitives/math"

	mock "github.com/stretchr/testify/mock"

	state "github.com/berachain/beacon-kit/state-transition/core/state"

	types "github.com/berachain/beacon-kit/node-api/handlers/beacon/types"
)

// Backend is an autogenerated mock type for the Backend type
type Backend struct {
	mock.Mock
}

type Backend_Expecter struct {
	mock *mock.Mock
}

func (_m *Backend) EXPECT() *Backend_Expecter {
	return &Backend_Expecter{mock: &_m.Mock}
}

// BlobSidecarsByIndices provides a mock function with given fields: slot, indices
func (_m *Backend) BlobSidecarsByIndices(slot math.U64, indices []uint64) ([]*types.Sidecar, error) {
	ret := _m.Called(slot, indices)

	if len(ret) == 0 {
		panic("no return value specified for BlobSidecarsByIndices")
	}

	var r0 []*types.Sidecar
	var r1 error
	if rf, ok := ret.Get(0).(func(math.U64, []uint64) ([]*types.Sidecar, error)); ok {
		return rf(slot, indices)
	}
	if rf, ok := ret.Get(0).(func(math.U64, []uint64) []*types.Sidecar); ok {
		r0 = rf(slot, indices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Sidecar)
		}
	}

	if rf, ok := ret.Get(1).(func(math.U64, []uint64) error); ok {
		r1 = rf(slot, indices)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Backend_BlobSidecarsByIndices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlobSidecarsByIndices'
type Backend_BlobSidecarsByIndices_Call struct {
	*mock.Call
}

// BlobSidecarsByIndices is a helper method to define mock.On call
//   - slot math.U64
//   - indices []uint64
func (_e *Backend_Expecter) BlobSidecarsByIndices(slot interface{}, indices interface{}) *Backend_BlobSidecarsByIndices_Call {
	return &Backend_BlobSidecarsByIndices_Call{Call: _e.mock.On("BlobSidecarsByIndices", slot, indices)}
}

func (_c *Backend_BlobSidecarsByIndices_Call) Run(run func(slot math.U64, indices []uint64)) *Backend_BlobSidecarsByIndices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64), args[1].([]uint64))
	})
	return _c
}

func (_c *Backend_BlobSidecarsByIndices_Call) Return(_a0 []*types.Sidecar, _a1 error) *Backend_BlobSidecarsByIndices_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Backend_BlobSidecarsByIndices_Call) RunAndReturn(run func(math.U64, []uint64) ([]*types.Sidecar, error)) *Backend_BlobSidecarsByIndices_Call {
	_c.Call.Return(run)
	return _c
}

// BlockHeaderAtSlot provides a mock function with given fields: slot
func (_m *Backend) BlockHeaderAtSlot(slot math.U64) (*consensus_typestypes.BeaconBlockHeader, error) {
	ret := _m.Called(slot)

	if len(ret) == 0 {
		panic("no return value specified for BlockHeaderAtSlot")
	}

	var r0 *consensus_typestypes.BeaconBlockHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(math.U64) (*consensus_typestypes.BeaconBlockHeader, error)); ok {
		return rf(slot)
	}
	if rf, ok := ret.Get(0).(func(math.U64) *consensus_typestypes.BeaconBlockHeader); ok {
		r0 = rf(slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*consensus_typestypes.BeaconBlockHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(math.U64) error); ok {
		r1 = rf(slot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Backend_BlockHeaderAtSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockHeaderAtSlot'
type Backend_BlockHeaderAtSlot_Call struct {
	*mock.Call
}

// BlockHeaderAtSlot is a helper method to define mock.On call
//   - slot math.U64
func (_e *Backend_Expecter) BlockHeaderAtSlot(slot interface{}) *Backend_BlockHeaderAtSlot_Call {
	return &Backend_BlockHeaderAtSlot_Call{Call: _e.mock.On("BlockHeaderAtSlot", slot)}
}

func (_c *Backend_BlockHeaderAtSlot_Call) Run(run func(slot math.U64)) *Backend_BlockHeaderAtSlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *Backend_BlockHeaderAtSlot_Call) Return(_a0 *consensus_typestypes.BeaconBlockHeader, _a1 error) *Backend_BlockHeaderAtSlot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Backend_BlockHeaderAtSlot_Call) RunAndReturn(run func(math.U64) (*consensus_typestypes.BeaconBlockHeader, error)) *Backend_BlockHeaderAtSlot_Call {
	_c.Call.Return(run)
	return _c
}

// BlockRewardsAtSlot provides a mock function with given fields: slot
func (_m *Backend) BlockRewardsAtSlot(slot math.U64) (*types.BlockRewardsData, error) {
	ret := _m.Called(slot)

	if len(ret) == 0 {
		panic("no return value specified for BlockRewardsAtSlot")
	}

	var r0 *types.BlockRewardsData
	var r1 error
	if rf, ok := ret.Get(0).(func(math.U64) (*types.BlockRewardsData, error)); ok {
		return rf(slot)
	}
	if rf, ok := ret.Get(0).(func(math.U64) *types.BlockRewardsData); ok {
		r0 = rf(slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockRewardsData)
		}
	}

	if rf, ok := ret.Get(1).(func(math.U64) error); ok {
		r1 = rf(slot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Backend_BlockRewardsAtSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockRewardsAtSlot'
type Backend_BlockRewardsAtSlot_Call struct {
	*mock.Call
}

// BlockRewardsAtSlot is a helper method to define mock.On call
//   - slot math.U64
func (_e *Backend_Expecter) BlockRewardsAtSlot(slot interface{}) *Backend_BlockRewardsAtSlot_Call {
	return &Backend_BlockRewardsAtSlot_Call{Call: _e.mock.On("BlockRewardsAtSlot", slot)}
}

func (_c *Backend_BlockRewardsAtSlot_Call) Run(run func(slot math.U64)) *Backend_BlockRewardsAtSlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *Backend_BlockRewardsAtSlot_Call) Return(_a0 *types.BlockRewardsData, _a1 error) *Backend_BlockRewardsAtSlot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Backend_BlockRewardsAtSlot_Call) RunAndReturn(run func(math.U64) (*types.BlockRewardsData, error)) *Backend_BlockRewardsAtSlot_Call {
	_c.Call.Return(run)
	return _c
}

// BlockRootAtSlot provides a mock function with given fields: slot
func (_m *Backend) BlockRootAtSlot(slot math.U64) (common.Root, error) {
	ret := _m.Called(slot)

	if len(ret) == 0 {
		panic("no return value specified for BlockRootAtSlot")
	}

	var r0 common.Root
	var r1 error
	if rf, ok := ret.Get(0).(func(math.U64) (common.Root, error)); ok {
		return rf(slot)
	}
	if rf, ok := ret.Get(0).(func(math.U64) common.Root); ok {
		r0 = rf(slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Root)
		}
	}

	if rf, ok := ret.Get(1).(func(math.U64) error); ok {
		r1 = rf(slot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Backend_BlockRootAtSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockRootAtSlot'
type Backend_BlockRootAtSlot_Call struct {
	*mock.Call
}

// BlockRootAtSlot is a helper method to define mock.On call
//   - slot math.U64
func (_e *Backend_Expecter) BlockRootAtSlot(slot interface{}) *Backend_BlockRootAtSlot_Call {
	return &Backend_BlockRootAtSlot_Call{Call: _e.mock.On("BlockRootAtSlot", slot)}
}

func (_c *Backend_BlockRootAtSlot_Call) Run(run func(slot math.U64)) *Backend_BlockRootAtSlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *Backend_BlockRootAtSlot_Call) Return(_a0 common.Root, _a1 error) *Backend_BlockRootAtSlot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Backend_BlockRootAtSlot_Call) RunAndReturn(run func(math.U64) (common.Root, error)) *Backend_BlockRootAtSlot_Call {
	_c.Call.Return(run)
	return _c
}

// GenesisForkVersion provides a mock function with given fields:
func (_m *Backend) GenesisForkVersion() (bytes.B4, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GenesisForkVersion")
	}

	var r0 bytes.B4
	var r1 error
	if rf, ok := ret.Get(0).(func() (bytes.B4, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bytes.B4); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(bytes.B4)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Backend_GenesisForkVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenesisForkVersion'
type Backend_GenesisForkVersion_Call struct {
	*mock.Call
}

// GenesisForkVersion is a helper method to define mock.On call
func (_e *Backend_Expecter) GenesisForkVersion() *Backend_GenesisForkVersion_Call {
	return &Backend_GenesisForkVersion_Call{Call: _e.mock.On("GenesisForkVersion")}
}

func (_c *Backend_GenesisForkVersion_Call) Run(run func()) *Backend_GenesisForkVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Backend_GenesisForkVersion_Call) Return(_a0 bytes.B4, _a1 error) *Backend_GenesisForkVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Backend_GenesisForkVersion_Call) RunAndReturn(run func() (bytes.B4, error)) *Backend_GenesisForkVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GenesisTime provides a mock function with given fields:
func (_m *Backend) GenesisTime() (math.U64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GenesisTime")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func() (math.U64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() math.U64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Backend_GenesisTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenesisTime'
type Backend_GenesisTime_Call struct {
	*mock.Call
}

// GenesisTime is a helper method to define mock.On call
func (_e *Backend_Expecter) GenesisTime() *Backend_GenesisTime_Call {
	return &Backend_GenesisTime_Call{Call: _e.mock.On("GenesisTime")}
}

func (_c *Backend_GenesisTime_Call) Run(run func()) *Backend_GenesisTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Backend_GenesisTime_Call) Return(_a0 math.U64, _a1 error) *Backend_GenesisTime_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Backend_GenesisTime_Call) RunAndReturn(run func() (math.U64, error)) *Backend_GenesisTime_Call {
	_c.Call.Return(run)
	return _c
}

// GenesisValidatorsRoot provides a mock function with given fields:
func (_m *Backend) GenesisValidatorsRoot() (common.Root, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GenesisValidatorsRoot")
	}

	var r0 common.Root
	var r1 error
	if rf, ok := ret.Get(0).(func() (common.Root, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() common.Root); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Root)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Backend_GenesisValidatorsRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenesisValidatorsRoot'
type Backend_GenesisValidatorsRoot_Call struct {
	*mock.Call
}

// GenesisValidatorsRoot is a helper method to define mock.On call
func (_e *Backend_Expecter) GenesisValidatorsRoot() *Backend_GenesisValidatorsRoot_Call {
	return &Backend_GenesisValidatorsRoot_Call{Call: _e.mock.On("GenesisValidatorsRoot")}
}

func (_c *Backend_GenesisValidatorsRoot_Call) Run(run func()) *Backend_GenesisValidatorsRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Backend_GenesisValidatorsRoot_Call) Return(_a0 common.Root, _a1 error) *Backend_GenesisValidatorsRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Backend_GenesisValidatorsRoot_Call) RunAndReturn(run func() (common.Root, error)) *Backend_GenesisValidatorsRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetSlotByBlockRoot provides a mock function with given fields: root
func (_m *Backend) GetSlotByBlockRoot(root common.Root) (math.U64, error) {
	ret := _m.Called(root)

	if len(ret) == 0 {
		panic("no return value specified for GetSlotByBlockRoot")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Root) (math.U64, error)); ok {
		return rf(root)
	}
	if rf, ok := ret.Get(0).(func(common.Root) math.U64); ok {
		r0 = rf(root)
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func(common.Root) error); ok {
		r1 = rf(root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Backend_GetSlotByBlockRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSlotByBlockRoot'
type Backend_GetSlotByBlockRoot_Call struct {
	*mock.Call
}

// GetSlotByBlockRoot is a helper method to define mock.On call
//   - root common.Root
func (_e *Backend_Expecter) GetSlotByBlockRoot(root interface{}) *Backend_GetSlotByBlockRoot_Call {
	return &Backend_GetSlotByBlockRoot_Call{Call: _e.mock.On("GetSlotByBlockRoot", root)}
}

func (_c *Backend_GetSlotByBlockRoot_Call) Run(run func(root common.Root)) *Backend_GetSlotByBlockRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Root))
	})
	return _c
}

func (_c *Backend_GetSlotByBlockRoot_Call) Return(_a0 math.U64, _a1 error) *Backend_GetSlotByBlockRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Backend_GetSlotByBlockRoot_Call) RunAndReturn(run func(common.Root) (math.U64, error)) *Backend_GetSlotByBlockRoot_Call {
	_c.Call.Return(run)
	return _c
}

// GetSlotByStateRoot provides a mock function with given fields: root
func (_m *Backend) GetSlotByStateRoot(root common.Root) (math.U64, error) {
	ret := _m.Called(root)

	if len(ret) == 0 {
		panic("no return value specified for GetSlotByStateRoot")
	}

	var r0 math.U64
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Root) (math.U64, error)); ok {
		return rf(root)
	}
	if rf, ok := ret.Get(0).(func(common.Root) math.U64); ok {
		r0 = rf(root)
	} else {
		r0 = ret.Get(0).(math.U64)
	}

	if rf, ok := ret.Get(1).(func(common.Root) error); ok {
		r1 = rf(root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Backend_GetSlotByStateRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSlotByStateRoot'
type Backend_GetSlotByStateRoot_Call struct {
	*mock.Call
}

// GetSlotByStateRoot is a helper method to define mock.On call
//   - root common.Root
func (_e *Backend_Expecter) GetSlotByStateRoot(root interface{}) *Backend_GetSlotByStateRoot_Call {
	return &Backend_GetSlotByStateRoot_Call{Call: _e.mock.On("GetSlotByStateRoot", root)}
}

func (_c *Backend_GetSlotByStateRoot_Call) Run(run func(root common.Root)) *Backend_GetSlotByStateRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.Root))
	})
	return _c
}

func (_c *Backend_GetSlotByStateRoot_Call) Return(_a0 math.U64, _a1 error) *Backend_GetSlotByStateRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Backend_GetSlotByStateRoot_Call) RunAndReturn(run func(common.Root) (math.U64, error)) *Backend_GetSlotByStateRoot_Call {
	_c.Call.Return(run)
	return _c
}

// StateAtSlot provides a mock function with given fields: slot
func (_m *Backend) StateAtSlot(slot math.U64) (*state.StateDB, math.U64, error) {
	ret := _m.Called(slot)

	if len(ret) == 0 {
		panic("no return value specified for StateAtSlot")
	}

	var r0 *state.StateDB
	var r1 math.U64
	var r2 error
	if rf, ok := ret.Get(0).(func(math.U64) (*state.StateDB, math.U64, error)); ok {
		return rf(slot)
	}
	if rf, ok := ret.Get(0).(func(math.U64) *state.StateDB); ok {
		r0 = rf(slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*state.StateDB)
		}
	}

	if rf, ok := ret.Get(1).(func(math.U64) math.U64); ok {
		r1 = rf(slot)
	} else {
		r1 = ret.Get(1).(math.U64)
	}

	if rf, ok := ret.Get(2).(func(math.U64) error); ok {
		r2 = rf(slot)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Backend_StateAtSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StateAtSlot'
type Backend_StateAtSlot_Call struct {
	*mock.Call
}

// StateAtSlot is a helper method to define mock.On call
//   - slot math.U64
func (_e *Backend_Expecter) StateAtSlot(slot interface{}) *Backend_StateAtSlot_Call {
	return &Backend_StateAtSlot_Call{Call: _e.mock.On("StateAtSlot", slot)}
}

func (_c *Backend_StateAtSlot_Call) Run(run func(slot math.U64)) *Backend_StateAtSlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(math.U64))
	})
	return _c
}

func (_c *Backend_StateAtSlot_Call) Return(_a0 *state.StateDB, _a1 math.U64, _a2 error) *Backend_StateAtSlot_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *Backend_StateAtSlot_Call) RunAndReturn(run func(math.U64) (*state.StateDB, math.U64, error)) *Backend_StateAtSlot_Call {
	_c.Call.Return(run)
	return _c
}

// NewBackend creates a new instance of Backend. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBackend(t interface {
	mock.TestingT
	Cleanup(func())
}) *Backend {
	mock := &Backend{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
